import { generateReportFromAssets, normalizePath } from "../src.mjs";
import { join, relative, resolve } from "path";

//#region src/entrypoints/parcel.ts
var Reporter = class {
	constructor(opts) {
		this[Symbol.for("parcel-plugin-config")] = opts;
	}
};
const SondaParcelPlugin = new Reporter({
	async loadConfig({ config }) {
		const conf = await config.getConfig([
			resolve(".sondarc"),
			resolve(".sondarc.js"),
			resolve("sonda.config.js")
		], {});
		return conf.contents;
	},
	async report({ event, options }) {
		if (event.type !== "buildSuccess") return;
		let inputs = {};
		const assets = [];
		for (let bundle of event.bundleGraph.getBundles()) {
			assets.push(bundle.filePath);
			bundle.traverseAssets((asset) => {
				const input = {
					bytes: asset.stats.size,
					format: asset.meta.hasCJSExports ? "cjs" : "esm",
					imports: [],
					belongsTo: null
				};
				for (let dep of event.bundleGraph.getDependencies(asset)) {
					let resolved = event.bundleGraph.getResolvedAsset(dep, bundle);
					if (resolved) input.imports.push(normalizePath(relative(process.cwd(), resolved.filePath)));
				}
				inputs[normalizePath(relative(process.cwd(), asset.filePath))] = input;
			});
		}
		return generateReportFromAssets(
			assets,
			inputs,
			// TODO: Use user provided options
			{
				format: "html",
				detailed: true,
				sources: true,
				gzip: true,
				brotli: true,
				sourcesPathNormalizer: (path) => join(options.projectRoot, path)
			}
);
	}
});
var parcel_default = SondaParcelPlugin;

//#endregion
export { parcel_default as default };
//# sourceMappingURL=parcel.mjs.map