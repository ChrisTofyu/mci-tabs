"use strict";
const require_src = require('../src.cjs');
const path = require_src.__toESM(require("path"));

//#region src/entrypoints/parcel.ts
var Reporter = class {
	constructor(opts) {
		this[Symbol.for("parcel-plugin-config")] = opts;
	}
};
const SondaParcelPlugin = new Reporter({
	async loadConfig({ config }) {
		const conf = await config.getConfig([
			(0, path.resolve)(".sondarc"),
			(0, path.resolve)(".sondarc.js"),
			(0, path.resolve)("sonda.config.js")
		], {});
		return conf.contents;
	},
	async report({ event, options }) {
		if (event.type !== "buildSuccess") return;
		let inputs = {};
		const assets = [];
		for (let bundle of event.bundleGraph.getBundles()) {
			assets.push(bundle.filePath);
			bundle.traverseAssets((asset) => {
				const input = {
					bytes: asset.stats.size,
					format: asset.meta.hasCJSExports ? "cjs" : "esm",
					imports: [],
					belongsTo: null
				};
				for (let dep of event.bundleGraph.getDependencies(asset)) {
					let resolved = event.bundleGraph.getResolvedAsset(dep, bundle);
					if (resolved) input.imports.push(require_src.normalizePath((0, path.relative)(process.cwd(), resolved.filePath)));
				}
				inputs[require_src.normalizePath((0, path.relative)(process.cwd(), asset.filePath))] = input;
			});
		}
		return require_src.generateReportFromAssets(
			assets,
			inputs,
			// TODO: Use user provided options
			{
				format: "html",
				detailed: true,
				sources: true,
				gzip: true,
				brotli: true,
				sourcesPathNormalizer: (path$1) => (0, path.join)(options.projectRoot, path$1)
			}
);
	}
});
var parcel_default = SondaParcelPlugin;

//#endregion
module.exports = parcel_default;
//# sourceMappingURL=parcel.cjs.map