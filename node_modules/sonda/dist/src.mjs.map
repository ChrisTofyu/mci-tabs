{"version":3,"file":"src.mjs","names":["esmRegex: RegExp","cjsRegex: RegExp","jsRegexp: RegExp","options?: Partial<PluginOptions>","format","defaultOptions: PluginOptions","pathToNormalize: string","options: PluginOptions","map: EncodedSourceMap","dirPath: string","inputs: Record<string, ReportInput>","path: string","format","code: string","map: DecodedSourceMap","assetSizes: Sizes","options: PluginOptions","mapping: SourceMapSegment | undefined","contributionsSum: Sizes","sources: Array<string | null>","sources: Map<string, Sizes>","asset: Sizes","sums: Sizes","assets: Array<string>","inputs: Record<string, ReportInput>","options: PluginOptions","asset: string","result: MaybeCodeMap","object: Record<string, T>","assets: string[]","inputs: JsonReport[ 'inputs' ]","pluginOptions: Partial<PluginOptions>","options: PluginOptions"],"sources":["../../load-source-map/dist/index.mjs","../src/utils.ts","../src/sourcemap/map.ts","../src/sourcemap/bytes.ts","../src/report/formats.ts","../src/report/generate.ts"],"sourcesContent":["import { existsSync, readFileSync, statSync } from \"fs\";\nimport { dirname, isAbsolute, join, resolve } from \"path\";\n\n//#region src/index.ts\n/**\n* Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification),\n* and parses the string as JSON.\n*\n* https://github.com/mozilla/source-map/blob/3cb92cc3b73bfab27c146bae4ef2bc09dbb4e5ed/lib/util.js#L162-L164\n*/\nfunction parseSourceMapInput(str) {\n\treturn JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\n/**\nsourceMappingURL=data:application/json;charset=utf-8;base64,data\nsourceMappingURL=data:application/json;base64,data\nsourceMappingURL=data:application/json;uri,data\nsourceMappingURL=map-file-comment.css.map\nsourceMappingURL=map-file-comment.css.map?query=value\n*/\nconst sourceMappingRegExp = /[@#]\\s*sourceMappingURL=(\\S+)\\b/g;\n/**\n* Checks if the given path is a file.\n*/\nfunction isFile(path) {\n\ttry {\n\t\treturn statSync(path).isFile();\n\t} catch {\n\t\treturn false;\n\t}\n}\nfunction loadCodeAndMap(codePath, sourcesPathNormalizer) {\n\tif (!isFile(codePath)) return null;\n\tconst code = readFileSync(codePath, \"utf-8\");\n\tconst extractedComment = code.includes(\"sourceMappingURL\") && Array.from(code.matchAll(sourceMappingRegExp)).at(-1);\n\tif (!extractedComment || !extractedComment.length) return { code };\n\tconst maybeMap = loadMap(codePath, extractedComment[1]);\n\tif (!maybeMap) return { code };\n\tconst { map, mapPath } = maybeMap;\n\tconst mapDir = dirname(mapPath);\n\tsourcesPathNormalizer ??= (path) => isAbsolute(path) ? path : resolve(mapDir, map.sourceRoot ?? \".\", path);\n\tmap.sources = normalizeSourcesPaths(map, sourcesPathNormalizer);\n\tmap.sourcesContent = loadMissingSourcesContent(map);\n\tdelete map.sourceRoot;\n\treturn {\n\t\tcode,\n\t\tmap\n\t};\n}\nfunction loadMap(codePath, sourceMappingURL) {\n\tif (sourceMappingURL.startsWith(\"data:\")) {\n\t\tconst map = parseDataUrl(sourceMappingURL);\n\t\treturn {\n\t\t\tmap: parseSourceMapInput(map),\n\t\t\tmapPath: codePath\n\t\t};\n\t}\n\tconst sourceMapFilename = new URL(sourceMappingURL, \"file://\").pathname;\n\tconst mapPath = join(dirname(codePath), sourceMapFilename);\n\tif (!existsSync(mapPath)) return null;\n\treturn {\n\t\tmap: parseSourceMapInput(readFileSync(mapPath, \"utf-8\")),\n\t\tmapPath\n\t};\n}\nfunction parseDataUrl(url) {\n\tconst [prefix, payload] = url.split(\",\");\n\tconst encoding = prefix.split(\";\").at(-1);\n\tswitch (encoding) {\n\t\tcase \"base64\": return Buffer.from(payload, \"base64\").toString();\n\t\tcase \"uri\": return decodeURIComponent(payload);\n\t\tdefault: throw new Error(\"Unsupported source map encoding: \" + encoding);\n\t}\n}\n/**\n* Normalize the paths of the sources in the source map to be absolute paths.\n*/\nfunction normalizeSourcesPaths(map, sourcesPathNormalizer) {\n\treturn map.sources.map((source) => source ? sourcesPathNormalizer(source) : null);\n}\n/**\n* Loop through the sources and try to load missing `sourcesContent` from the file system.\n*/\nfunction loadMissingSourcesContent(map) {\n\treturn map.sources.map((source, index) => {\n\t\tif (map.sourcesContent?.[index]) return map.sourcesContent[index];\n\t\tif (source && existsSync(source)) return readFileSync(source, \"utf-8\");\n\t\treturn null;\n\t});\n}\n\n//#endregion\nexport { loadCodeAndMap };\n//# sourceMappingURL=index.mjs.map","import { join, relative, win32, posix, extname, isAbsolute, format, parse } from 'path';\nimport type { PluginOptions } from './types.js';\n\nexport const esmRegex: RegExp = /\\.m[tj]sx?$/;\nexport const cjsRegex: RegExp = /\\.c[tj]sx?$/;\nexport const jsRegexp: RegExp = /\\.[cm]?[tj]s[x]?$/;\n\nexport function normalizeOptions( options?: Partial<PluginOptions> ): PluginOptions {\n\tconst format = options?.format\n\t\t|| options?.filename?.split( '.' ).at( -1 ) as PluginOptions['format']\n\t\t|| 'html';\n\n\tconst defaultOptions: PluginOptions = {\n\t\tenabled: true,\n\t\tformat,\n\t\tfilename: 'sonda-report.' + format,\n\t\topen: true,\n\t\tdetailed: false,\n\t\tsources: false,\n\t\tgzip: false,\n\t\tbrotli: false, \n\t\tsourcesPathNormalizer: null,\n\t};\n\n\t// Merge user options with the defaults\n\tconst normalizedOptions = Object.assign( {}, defaultOptions, options ) satisfies PluginOptions;\n\n\tnormalizedOptions.filename = normalizeOutputPath( normalizedOptions );\n\n\treturn normalizedOptions;\n}\n\nexport function normalizePath( pathToNormalize: string ): string {\n\t// Unicode escape sequences used by Rollup and Vite to identify virtual modules\n\tconst normalized = pathToNormalize.replace( /^\\0/, '' )\n\n\t// Transform absolute paths to relative paths\n\tconst relativized = relative( process.cwd(), normalized );\n\n\t// Ensure paths are POSIX-compliant - https://stackoverflow.com/a/63251716/4617687\n\treturn relativized.replaceAll( win32.sep, posix.sep );\n}\n\nfunction normalizeOutputPath( options: PluginOptions ): string {\n\tlet path = options.filename;\n\tconst expectedExtension = '.' + options.format;\n\n\t// Ensure the filename is an absolute path\n\tif ( !isAbsolute( path ) ) {\n\t\tpath = join( process.cwd(), path );\n\t}\n\n\t// Ensure that the `filename` extension matches the `format` option\n\tif ( expectedExtension !== extname( path ) ) {\n\t\tconsole.warn(\n\t\t\t'\\x1b[0;33m' + // Make the message yellow\n\t\t\t`Sonda: The file extension specified in the 'filename' does not match the 'format' option. ` +\n\t\t\t`The extension will be changed to '${ expectedExtension }'.`\n\t\t);\n\n\t\tpath = format( { ...parse( path ), base: '', ext: expectedExtension } )\n\t}\n\n\treturn path;\n}\n","import { default as remapping, type DecodedSourceMap, type EncodedSourceMap } from '@ampproject/remapping';\nimport { loadCodeAndMap } from 'load-source-map';\nimport { resolve } from 'path';\nimport { normalizePath } from '../utils.js';\nimport type { CodeMap, ReportInput } from '../types.js';\n\nexport function mapSourceMap(\n\tmap: EncodedSourceMap,\n\tdirPath: string,\n\tinputs: Record<string, ReportInput>\n): DecodedSourceMap {\n\tconst alreadyRemapped = new Set<string>();\n\tconst remapped = remapping( map, ( file, ctx ) => {\n\t\tif ( alreadyRemapped.has( file ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\talreadyRemapped.add( file );\n\n\t\tconst codeMap = addSourcesToInputs(\n\t\t\tresolve( dirPath, file ),\n\t\t\tinputs\n\t\t);\n\n\t\tif ( !codeMap ) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.content ??= codeMap.code;\n\n\t\treturn codeMap.map;\n\t}, { decodedMappings: true } );\n\n\treturn remapped as DecodedSourceMap;\n}\n\n/**\n * Loads the source map of a given file and adds its \"sources\" to the given inputs object.\n */\nexport function addSourcesToInputs(\n\tpath: string,\n\tinputs: Record<string, ReportInput>\n): CodeMap | null {\n\tconst codeMap = loadCodeAndMap( path );\n\n\tif ( !codeMap ) {\n\t\treturn null;\n\t}\n\n\tconst parentPath = normalizePath( path );\n\tconst format = inputs[ parentPath ]?.format ?? 'unknown';\n\n\tcodeMap.map?.sources\n\t\t.filter( source => source !== null )\n\t\t.forEach( ( source, index ) => {\n\t\t\tconst normalizedPath = normalizePath( source );\n\n\t\t\tif ( parentPath === normalizedPath ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinputs[ normalizedPath ] = {\n\t\t\t\tbytes: Buffer.byteLength( codeMap.map!.sourcesContent?.[ index ] ?? '' ),\n\t\t\t\tformat,\n\t\t\t\timports: [],\n\t\t\t\tbelongsTo: parentPath\n\t\t\t};\n\t\t} );\n\t\n\treturn codeMap;\n}\n","import { gzipSync, brotliCompressSync } from 'zlib';\nimport type { DecodedSourceMap, SourceMapSegment } from '@ampproject/remapping';\nimport type { PluginOptions, Sizes } from '../types.js';\n\nconst UNASSIGNED = '[unassigned]';\n\nexport function getBytesPerSource(\n\tcode: string,\n\tmap: DecodedSourceMap,\n\tassetSizes: Sizes,\n\toptions: PluginOptions\n): Map<string, Sizes> {\n\tconst contributions = getContributions( map.sources );\n\n\t// Split the code into lines\n\tconst codeLines = code.split( /(?<=\\r?\\n)/ );\n\n\tfor ( let lineIndex = 0; lineIndex < codeLines.length; lineIndex++ ) {\n\t\tconst lineCode = codeLines[ lineIndex ];\n\t\tconst mappings = map.mappings[ lineIndex ] || [];\n\t\tlet currentColumn = 0;\n\n\t\tfor ( let i = 0; i <= mappings.length; i++ ) {\n\t\t\t// 0: generatedColumn\n\t\t\t// 1: sourceIndex\n\t\t\t// 2: originalLine\n\t\t\t// 3: originalColumn\n\t\t\t// 4: nameIndex\n\n\t\t\tconst mapping: SourceMapSegment | undefined = mappings[ i ];\n\t\t\tconst startColumn = mapping?.[ 0 ] ?? lineCode.length;\n\t\t\tconst endColumn = mappings[ i + 1 ]?.[ 0 ] ?? lineCode.length;\n\n\t\t\t// Slice the code from currentColumn to startColumn for unassigned code\n\t\t\tif ( startColumn > currentColumn ) {\n\t\t\t\tcontributions.set( UNASSIGNED, contributions.get( UNASSIGNED ) + lineCode.slice( currentColumn, startColumn ) );\n\t\t\t}\n\n\t\t\tif ( mapping ) {\n\t\t\t\t// Slice the code from startColumn to endColumn for assigned code\n\t\t\t\tconst sourceIndex = mapping?.[ 1 ];\n\t\t\t\tconst codeSlice = lineCode.slice( startColumn, endColumn );\n\t\t\t\tconst source = sourceIndex !== undefined && map.sources[ sourceIndex ] || UNASSIGNED;\n\n\t\t\t\tcontributions.set( source, contributions.get( source ) + codeSlice );\n\t\t\t\tcurrentColumn = endColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumn = startColumn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compute sizes for each source\n\tconst sourceSizes = new Map<string, Sizes>();\n\n\tconst contributionsSum: Sizes = {\n\t\tuncompressed: 0,\n\t\tgzip: 0,\n\t\tbrotli: 0\n\t};\n\n\tfor ( const [ source, codeSegment ] of contributions ) {\n\t\tconst sizes = getSizes( codeSegment, options );\n\n\t\tcontributionsSum.uncompressed += sizes.uncompressed;\n\t\tcontributionsSum.gzip += sizes.gzip;\n\t\tcontributionsSum.brotli += sizes.brotli;\n\n\t\tsourceSizes.set( source, sizes );\n\t}\n\n\treturn adjustSizes( sourceSizes, assetSizes, contributionsSum, options );\n}\n\nexport function getSizes(\n\tcode: string,\n\toptions: PluginOptions\n): Sizes {\n\treturn {\n\t\tuncompressed: Buffer.byteLength( code ),\n\t\tgzip: options.gzip ? gzipSync( code ).length : 0,\n\t\tbrotli: options.brotli ? brotliCompressSync( code ).length : 0\n\t};\n}\n\nfunction getContributions( sources: Array<string | null> ): Map<string, string> {\n\tconst contributions = new Map<string, string>();\n\n\t// Populate contributions with sources\n\tsources\n\t\t.filter( source => source !== null )\n\t\t.forEach( source => contributions.set( source, '' ) );\n\n\t// Add entry for the code that is not assigned to any source\n\tcontributions.set( UNASSIGNED, '' );\n\n\treturn contributions;\n}\n\n/**\n * Compression efficiency improves with the size of the file.\n *\n * However, what we have is the compressed size of the entire bundle (`actual`),\n * the sum of all files compressed individually (`sum`) and the compressed\n * size of a given file (`content`). The last value is essentially a “worst-case”\n * scenario, and the actual size of the file in the bundle is likely to be smaller.\n *\n * We use this information to estimate the actual size of the file in the bundle\n * after compression.\n */\nfunction adjustSizes(\n\tsources: Map<string, Sizes>,\n\tasset: Sizes,\n\tsums: Sizes,\n\toptions: PluginOptions\n): Map<string, Sizes> {\n\tconst gzipDelta = options.gzip ? asset.gzip / sums.gzip : 0;\n\tconst brotliDelta = options.brotli ? asset.brotli / sums.brotli : 0;\n\n\tfor ( const [ source, sizes ] of sources ) {\n\t\tsources.set( source, {\n\t\t\tuncompressed: sizes.uncompressed,\n\t\t\tgzip: options.gzip ? Math.round( sizes.gzip * gzipDelta ) : 0,\n\t\t\tbrotli: options.brotli ? Math.round( sizes.brotli * brotliDelta ) : 0\n\t\t} );\n\t}\n\n\treturn sources;\n}\n","import { readFileSync } from 'fs';\nimport { fileURLToPath } from 'url';\nimport { dirname, extname, resolve } from 'path';\nimport { loadCodeAndMap } from 'load-source-map';\nimport { decode } from '@jridgewell/sourcemap-codec';\nimport { mapSourceMap } from '../sourcemap/map.js';\nimport { getBytesPerSource, getSizes } from '../sourcemap/bytes.js';\nimport type {\n  JsonReport,\n  MaybeCodeMap,\n  ReportInput,\n  ReportOutput,\n  CodeMap,\n  ReportOutputInput,\n  PluginOptions\n} from '../types.js';\nimport { normalizePath } from '../utils.js';\n\nexport function generateJsonReport(\n  assets: Array<string>,\n  inputs: Record<string, ReportInput>,\n  options: PluginOptions\n): JsonReport {\n  const acceptedExtensions = [ '.js', '.mjs', '.cjs', '.css' ];\n\n  const outputs = assets\n    .filter( asset => acceptedExtensions.includes( extname( asset ) ) )\n    .reduce( ( carry, asset ) => {\n      const data = processAsset( asset, inputs, options );\n\n      if ( data ) {\n        carry[ normalizePath( asset ) ] = data;\n      }\n\n      return carry;\n    }, {} as Record<string, ReportOutput> );\n\n  return {\n    inputs: sortObjectKeys( inputs ),\n    outputs: sortObjectKeys( outputs )\n  };\n}\n\nexport function generateHtmlReport(\n  assets: Array<string>,\n  inputs: Record<string, ReportInput>,\n  options: PluginOptions\n): string {\n  const json = generateJsonReport( assets, inputs, options );\n  // Replace with `import.meta.dirname` after upgrading to Node 20\n  const __dirname = dirname( fileURLToPath( import.meta.url ) );\n  const template = readFileSync( resolve( __dirname, './index.html' ), 'utf-8' );\n\n  return template.replace( '__REPORT_DATA__', encodeURIComponent( JSON.stringify( json ) ) );\n}\n\nfunction processAsset(\n  asset: string,\n  inputs: Record<string, ReportInput>,\n  options: PluginOptions\n): ReportOutput | void {\n  const maybeCodeMap = loadCodeAndMap( asset, options.sourcesPathNormalizer );\n\n  if ( !hasCodeAndMap( maybeCodeMap ) ) {\n    return;\n  }\n\n  const { code, map } = maybeCodeMap;\n  const mapped = options.detailed\n    ? mapSourceMap( map, dirname( asset ), inputs )\n    : { ...map, mappings: decode( map.mappings ) };\n\n  mapped.sources = mapped.sources.map( source => source && normalizePath( source ) );\n\n  const assetSizes = getSizes( code, options );\n  const bytes = getBytesPerSource( code, mapped, assetSizes, options );\n  const outputInputs = Array\n    .from( bytes )\n    .reduce( ( carry, [ source, sizes ] ) => {\n      carry[ normalizePath( source ) ] = sizes;\n\n      return carry;\n    }, {} as Record<string, ReportOutputInput> );\n\n  return {\n    ...assetSizes,\n    inputs: sortObjectKeys( outputInputs ),\n    map: options.sources ? {\n      version: 3,\n      names: [],\n      mappings: mapped.mappings,\n      sources: mapped.sources,\n      sourcesContent: mapped.sourcesContent,\n    } : undefined\n  };\n}\n\nfunction hasCodeAndMap( result: MaybeCodeMap ): result is Required<CodeMap> {\n  return Boolean( result && result.code && result.map );\n}\n\nfunction sortObjectKeys<T extends unknown>( object: Record<string, T> ): Record<string, T> {\n  return Object\n    .keys( object )\n    .sort()\n    .reduce( ( carry, key ) => {\n      carry[ key ] = object[ key ];\n\n      return carry;\n    }, {} as Record<string, T> );\n} \n","import { dirname } from 'path';\nimport { existsSync, mkdirSync, writeFileSync } from 'fs';\nimport { generateHtmlReport, generateJsonReport } from './formats.js';\nimport type { PluginOptions, JsonReport } from '../types.js';\nimport { normalizeOptions } from '../utils.js';\n\nexport async function generateReportFromAssets(\n\tassets: string[],\n\tinputs: JsonReport[ 'inputs' ],\n\tpluginOptions: Partial<PluginOptions>\n): Promise<void> {\n\tconst options = normalizeOptions( pluginOptions );\n\tconst handler = options.format === 'html' ? saveHtml : saveJson;\n\tconst report = handler( assets, inputs, options );\n\tconst outputDirectory = dirname( options.filename );\n\n\t// Ensure the output directory exists\n\tif ( !existsSync( outputDirectory ) ) {\n\t\tmkdirSync( outputDirectory, { recursive: true } );\n\t}\n\n\t// Write the report to the file system\n\twriteFileSync( options.filename, report );\n\n\tif ( !options.open ) {\n\t\treturn;\n\t}\n\n\t/**\n\t * `open` is ESM-only package, so we need to import it\n\t * dynamically to make it work in CommonJS environment.\n\t */\n\tconst { default: open } = await import( 'open' );\n\n\t// Open the report in the default program for the file extension\n\topen( options.filename );\n}\n\nfunction saveHtml(\n\tassets: string[],\n\tinputs: JsonReport[ 'inputs' ],\n\toptions: PluginOptions\n): string {\n\treturn generateHtmlReport( assets, inputs, options );\n}\n\nfunction saveJson(\n\tassets: string[],\n\tinputs: JsonReport[ 'inputs' ],\n\toptions: PluginOptions\n): string {\n\tconst report = generateJsonReport( assets, inputs, options );\n\n\treturn JSON.stringify( report, null, 2 );\n}\n"],"mappings":"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"}