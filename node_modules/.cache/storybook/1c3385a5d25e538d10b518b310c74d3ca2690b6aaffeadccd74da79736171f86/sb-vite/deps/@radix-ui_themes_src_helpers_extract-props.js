import {
  require_classnames
} from "./chunk-ESZL3PYD.js";
import {
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/@radix-ui/themes/src/helpers/extract-props.ts
var import_classnames = __toESM(require_classnames());

// node_modules/@radix-ui/themes/src/props/prop-def.ts
var breakpoints = ["initial", "xs", "sm", "md", "lg", "xl"];

// node_modules/@radix-ui/themes/src/helpers/has-own-property.ts
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

// node_modules/@radix-ui/themes/src/helpers/is-responsive-object.ts
function isResponsiveObject(obj) {
  return typeof obj === "object" && Object.keys(obj).some((key) => breakpoints.includes(key));
}

// node_modules/@radix-ui/themes/src/helpers/get-responsive-styles.ts
function getResponsiveStyles({ className, customProperties, ...args }) {
  const responsiveClassNames = getResponsiveClassNames({
    allowArbitraryValues: true,
    className,
    ...args
  });
  const responsiveCustomProperties = getResponsiveCustomProperties({ customProperties, ...args });
  return [responsiveClassNames, responsiveCustomProperties];
}
function getResponsiveClassNames({
  allowArbitraryValues,
  value,
  className,
  propValues,
  parseValue = (value2) => value2
}) {
  const classNames2 = [];
  if (!value) {
    return void 0;
  }
  if (typeof value === "string" && propValues.includes(value)) {
    return getBaseClassName(className, value, parseValue);
  }
  if (isResponsiveObject(value)) {
    const object = value;
    for (const bp in object) {
      if (!hasOwnProperty(object, bp) || !breakpoints.includes(bp)) {
        continue;
      }
      const value2 = object[bp];
      if (value2 !== void 0) {
        if (propValues.includes(value2)) {
          const baseClassName = getBaseClassName(className, value2, parseValue);
          const bpClassName = bp === "initial" ? baseClassName : `${bp}:${baseClassName}`;
          classNames2.push(bpClassName);
        } else if (allowArbitraryValues) {
          const bpClassName = bp === "initial" ? className : `${bp}:${className}`;
          classNames2.push(bpClassName);
        }
      }
    }
    return classNames2.join(" ");
  }
  if (allowArbitraryValues) {
    return className;
  }
}
function getBaseClassName(className, value, parseValue) {
  const delimiter = className ? "-" : "";
  const matchedValue = parseValue(value);
  const isNegative = matchedValue == null ? void 0 : matchedValue.startsWith("-");
  const minus = isNegative ? "-" : "";
  const absoluteValue = isNegative ? matchedValue == null ? void 0 : matchedValue.substring(1) : matchedValue;
  return `${minus}${className}${delimiter}${absoluteValue}`;
}
function getResponsiveCustomProperties({
  customProperties,
  value,
  propValues,
  parseValue = (value2) => value2
}) {
  let styles = {};
  if (!value || typeof value === "string" && propValues.includes(value)) {
    return void 0;
  }
  if (typeof value === "string") {
    styles = Object.fromEntries(customProperties.map((prop) => [prop, value]));
  }
  if (isResponsiveObject(value)) {
    const object = value;
    for (const bp in object) {
      if (!hasOwnProperty(object, bp) || !breakpoints.includes(bp)) {
        continue;
      }
      const value2 = object[bp];
      if (propValues.includes(value2)) {
        continue;
      }
      for (const customProperty of customProperties) {
        const bpProperty = bp === "initial" ? customProperty : `${customProperty}-${bp}`;
        styles = {
          [bpProperty]: value2,
          ...styles
        };
      }
    }
  }
  for (const key in styles) {
    const value2 = styles[key];
    if (value2 !== void 0) {
      styles[key] = parseValue(value2);
    }
  }
  return styles;
}

// node_modules/@radix-ui/themes/src/helpers/merge-styles.ts
function mergeStyles(...styles) {
  let result = {};
  for (const style of styles) {
    if (style) {
      result = { ...result, ...style };
    }
  }
  return Object.keys(result).length ? result : void 0;
}

// node_modules/@radix-ui/themes/src/helpers/extract-props.ts
function mergePropDefs(...args) {
  return Object.assign({}, ...args);
}
function extractProps(props, ...propDefs) {
  let className;
  let style;
  const extractedProps = { ...props };
  const allPropDefs = mergePropDefs(...propDefs);
  for (const key in allPropDefs) {
    let value = extractedProps[key];
    const propDef = allPropDefs[key];
    if (propDef.default !== void 0 && value === void 0) {
      value = propDef.default;
    }
    if (propDef.type === "enum") {
      const values = [propDef.default, ...propDef.values];
      if (!values.includes(value) && !isResponsiveObject(value)) {
        value = propDef.default;
      }
    }
    extractedProps[key] = value;
    if ("className" in propDef && propDef.className) {
      delete extractedProps[key];
      const isResponsivePropDef = "responsive" in propDef;
      if (!value || isResponsiveObject(value) && !isResponsivePropDef) {
        continue;
      }
      if (isResponsiveObject(value)) {
        if (propDef.default !== void 0 && value.initial === void 0) {
          value.initial = propDef.default;
        }
        if (propDef.type === "enum") {
          const values = [propDef.default, ...propDef.values];
          if (!values.includes(value.initial)) {
            value.initial = propDef.default;
          }
        }
      }
      if (propDef.type === "enum") {
        const propClassName = getResponsiveClassNames({
          allowArbitraryValues: false,
          value,
          className: propDef.className,
          propValues: propDef.values,
          parseValue: propDef.parseValue
        });
        className = (0, import_classnames.default)(className, propClassName);
        continue;
      }
      if (propDef.type === "string" || propDef.type === "enum | string") {
        const propDefValues = propDef.type === "string" ? [] : propDef.values;
        const [propClassNames, propCustomProperties] = getResponsiveStyles({
          className: propDef.className,
          customProperties: propDef.customProperties,
          propValues: propDefValues,
          parseValue: propDef.parseValue,
          value
        });
        style = mergeStyles(style, propCustomProperties);
        className = (0, import_classnames.default)(className, propClassNames);
        continue;
      }
      if (propDef.type === "boolean" && value) {
        className = (0, import_classnames.default)(className, propDef.className);
        continue;
      }
    }
  }
  extractedProps.className = (0, import_classnames.default)(className, props.className);
  extractedProps.style = mergeStyles(style, props.style);
  return extractedProps;
}
export {
  extractProps
};
//# sourceMappingURL=@radix-ui_themes_src_helpers_extract-props.js.map
