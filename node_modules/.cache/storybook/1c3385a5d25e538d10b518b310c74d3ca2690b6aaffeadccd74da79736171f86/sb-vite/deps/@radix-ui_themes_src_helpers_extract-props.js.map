{
  "version": 3,
  "sources": ["../../../../../@radix-ui/themes/src/helpers/extract-props.ts", "../../../../../@radix-ui/themes/src/props/prop-def.ts", "../../../../../@radix-ui/themes/src/helpers/has-own-property.ts", "../../../../../@radix-ui/themes/src/helpers/is-responsive-object.ts", "../../../../../@radix-ui/themes/src/helpers/get-responsive-styles.ts", "../../../../../@radix-ui/themes/src/helpers/merge-styles.ts"],
  "sourcesContent": ["import classNames from 'classnames';\n\nimport { getResponsiveClassNames, getResponsiveStyles } from './get-responsive-styles.js';\nimport { isResponsiveObject } from './is-responsive-object.js';\nimport { mergeStyles } from './merge-styles.js';\n\nimport type * as React from 'react';\nimport type { PropDef } from '../props/prop-def.js';\n\ntype PropDefsWithClassName<T> = T extends Record<string, PropDef>\n  ? { [K in keyof T]: T[K] extends { className: string } ? K : never }[keyof T]\n  : never;\n\nfunction mergePropDefs<T extends Record<string, PropDef>[]>(...args: T): Record<string, PropDef> {\n  return Object.assign({}, ...args);\n}\n\n/**\n * Takes props, checks them against prop defs that have a `className` on them,\n * adds necessary CSS classes and inline styles, and returns the props without\n * the corresponding prop defs that were used to formulate the new `className`\n * and `style` values. Also applies prop def defaults to every prop.\n */\nfunction extractProps<\n  P extends { className?: string; style?: React.CSSProperties; [key: string]: any },\n  T extends Record<string, PropDef>[]\n>(\n  props: P,\n  ...propDefs: T\n): Omit<P & { className?: string; style?: React.CSSProperties }, PropDefsWithClassName<T[number]>> {\n  let className: string | undefined;\n  let style: ReturnType<typeof mergeStyles>;\n  const extractedProps = { ...props };\n  const allPropDefs = mergePropDefs(...propDefs);\n\n  for (const key in allPropDefs) {\n    let value = extractedProps[key];\n    const propDef = allPropDefs[key];\n\n    // Apply prop def defaults\n    if (propDef.default !== undefined && value === undefined) {\n      value = propDef.default;\n    }\n\n    // Apply the default value if the value is not a valid enum value\n    if (propDef.type === 'enum') {\n      const values = [propDef.default, ...propDef.values];\n\n      if (!values.includes(value) && !isResponsiveObject(value)) {\n        value = propDef.default;\n      }\n    }\n\n    // Apply the value with defaults\n    (extractedProps as Record<string, any>)[key] = value;\n\n    if ('className' in propDef && propDef.className) {\n      delete extractedProps[key];\n\n      const isResponsivePropDef = 'responsive' in propDef;\n      // Make sure we are not threading through responsive values for non-responsive prop defs\n      if (!value || (isResponsiveObject(value) && !isResponsivePropDef)) {\n        continue;\n      }\n\n      if (isResponsiveObject(value)) {\n        // Apply prop def defaults to the `initial` breakpoint\n        if (propDef.default !== undefined && value.initial === undefined) {\n          value.initial = propDef.default;\n        }\n\n        // Apply the default value to the `initial` breakpoint when it is not a valid enum value\n        if (propDef.type === 'enum') {\n          const values = [propDef.default, ...propDef.values];\n\n          if (!values.includes(value.initial)) {\n            value.initial = propDef.default;\n          }\n        }\n      }\n\n      if (propDef.type === 'enum') {\n        const propClassName = getResponsiveClassNames({\n          allowArbitraryValues: false,\n          value,\n          className: propDef.className,\n          propValues: propDef.values,\n          parseValue: propDef.parseValue,\n        });\n\n        className = classNames(className, propClassName);\n        continue;\n      }\n\n      if (propDef.type === 'string' || propDef.type === 'enum | string') {\n        const propDefValues = propDef.type === 'string' ? [] : propDef.values;\n\n        const [propClassNames, propCustomProperties] = getResponsiveStyles({\n          className: propDef.className,\n          customProperties: propDef.customProperties,\n          propValues: propDefValues,\n          parseValue: propDef.parseValue,\n          value,\n        });\n\n        style = mergeStyles(style, propCustomProperties);\n        className = classNames(className, propClassNames);\n        continue;\n      }\n\n      if (propDef.type === 'boolean' && value) {\n        // TODO handle responsive boolean props\n        className = classNames(className, propDef.className);\n        continue;\n      }\n    }\n  }\n\n  extractedProps.className = classNames(className, props.className);\n  extractedProps.style = mergeStyles(style, props.style);\n  return extractedProps;\n}\n\nexport { extractProps };\n", "import type React from 'react';\n\n// Creates a union type of string literals with strings, but retains intellisense for the literals.\n// Union<string, 'foo' | 'bar'> => string | Omit<string, 'foo' | 'bar'>\ntype Union<S = string, T extends string | number = string> = T | Omit<S, T>;\n\nconst breakpoints = ['initial', 'xs', 'sm', 'md', 'lg', 'xl'] as const;\ntype Breakpoint = (typeof breakpoints)[number];\ntype Responsive<T> = T | Partial<Record<Breakpoint, T>>;\n\ntype BooleanPropDef = {\n  type: 'boolean';\n  default?: boolean;\n  required?: boolean;\n  className?: string;\n};\ntype StringPropDef = {\n  type: 'string';\n  default?: string;\n  required?: boolean;\n};\ntype ReactNodePropDef = {\n  type: 'ReactNode';\n  default?: React.ReactNode;\n  required?: boolean;\n};\ntype EnumPropDef<T> = {\n  type: 'enum';\n  values: readonly T[];\n  default?: T;\n  required?: boolean;\n};\ntype EnumOrStringPropDef<T> = {\n  type: 'enum | string';\n  values: readonly T[];\n  default?: T | string;\n  required?: boolean;\n};\n\ntype NonStylingPropDef = {\n  className?: never;\n  customProperties?: never;\n  parseValue?: never;\n};\n\ntype StylingPropDef = {\n  className: string;\n  parseValue?: (value: string) => string | undefined;\n};\n\ntype ArbitraryStylingPropDef = {\n  className: string;\n  customProperties: `--${string}`[];\n  parseValue?: (value: string) => string | undefined;\n};\n\ntype RegularPropDef<T> =\n  | ReactNodePropDef\n  | BooleanPropDef\n  | (StringPropDef & ArbitraryStylingPropDef)\n  | (StringPropDef & NonStylingPropDef)\n  | (EnumPropDef<T> & StylingPropDef)\n  | (EnumPropDef<T> & NonStylingPropDef)\n  | (EnumOrStringPropDef<T> & ArbitraryStylingPropDef)\n  | (EnumOrStringPropDef<T> & NonStylingPropDef);\ntype ResponsivePropDef<T = any> = RegularPropDef<T> & { responsive: true };\ntype PropDef<T = any> = RegularPropDef<T> | ResponsivePropDef<T>;\n\n// prettier-ignore\ntype GetPropDefType<Def> =\n    Def extends BooleanPropDef ? (Def extends ResponsivePropDef ? Responsive<boolean> : boolean)\n  : Def extends StringPropDef ? (Def extends ResponsivePropDef ? Responsive<string> : string)\n  : Def extends ReactNodePropDef ? (Def extends ResponsivePropDef ? Responsive<React.ReactNode> : React.ReactNode)\n  : Def extends EnumOrStringPropDef<infer Type> ?\n    Def extends ResponsivePropDef<infer Type extends string> ? Responsive<Union<string, Type>> : Type\n  : Def extends EnumPropDef<infer Type> ? (Def extends ResponsivePropDef<infer Type> ? Responsive<Type> : Type)\n  : never;\n\ntype GetPropDefTypes<P> = {\n  [K in keyof P]?: GetPropDefType<P[K]>;\n};\n\nexport { breakpoints };\nexport type {\n  PropDef,\n  GetPropDefTypes,\n  ResponsivePropDef,\n  //\n  Breakpoint,\n  Responsive,\n  Union,\n};\n", "/** A util to check whether the object has a key, while inferring the correct key type */\nfunction hasOwnProperty<K extends string | number | symbol>(\n  obj: Record<K, unknown>,\n  key: string | number | symbol\n): key is K {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport { hasOwnProperty };\n", "import { breakpoints } from '../props/prop-def.js';\n\nimport type { Responsive, Breakpoint } from '../props/prop-def.js';\n\nexport function isResponsiveObject<Value extends string>(\n  obj: Responsive<Value | Omit<string, Value>> | undefined\n): obj is Record<Breakpoint, string> {\n  return (\n    typeof obj === 'object' &&\n    Object.keys(obj).some((key) => (breakpoints as readonly string[]).includes(key))\n  );\n}\n", "import { breakpoints } from '../props/prop-def.js';\nimport { hasOwnProperty } from './has-own-property.js';\nimport { isResponsiveObject } from './is-responsive-object.js';\n\nimport type { Responsive, Union } from '../props/prop-def.js';\n\ninterface GetResponsiveStylesOptions {\n  className: string;\n  customProperties: `--${string}`[];\n  value: Responsive<Union> | Responsive<string> | undefined;\n  propValues: string[] | readonly string[];\n  parseValue?: (value: string) => string | undefined;\n}\n\nfunction getResponsiveStyles({ className, customProperties, ...args }: GetResponsiveStylesOptions) {\n  const responsiveClassNames = getResponsiveClassNames({\n    allowArbitraryValues: true,\n    className,\n    ...args,\n  });\n\n  const responsiveCustomProperties = getResponsiveCustomProperties({ customProperties, ...args });\n  return [responsiveClassNames, responsiveCustomProperties] as const;\n}\n\ninterface GetResponsiveClassNamesOptions {\n  allowArbitraryValues?: boolean;\n  className: string;\n  value: Responsive<Union> | Responsive<string> | undefined;\n  propValues: string[] | readonly string[];\n  parseValue?: (value: string) => string | undefined;\n}\n\nfunction getResponsiveClassNames({\n  allowArbitraryValues,\n  value,\n  className,\n  propValues,\n  parseValue = (value) => value,\n}: GetResponsiveClassNamesOptions): string | undefined {\n  const classNames: string[] = [];\n\n  if (!value) {\n    return undefined;\n  }\n\n  if (typeof value === 'string' && propValues.includes(value)) {\n    return getBaseClassName(className, value, parseValue);\n  }\n\n  if (isResponsiveObject(value)) {\n    const object = value;\n\n    for (const bp in object) {\n      // Make sure we are not iterating over keys that aren't breakpoints\n      if (!hasOwnProperty(object, bp) || !breakpoints.includes(bp)) {\n        continue;\n      }\n\n      const value = object[bp];\n\n      if (value !== undefined) {\n        if (propValues.includes(value)) {\n          const baseClassName = getBaseClassName(className, value, parseValue);\n          const bpClassName = bp === 'initial' ? baseClassName : `${bp}:${baseClassName}`;\n          classNames.push(bpClassName);\n        } else if (allowArbitraryValues) {\n          const bpClassName = bp === 'initial' ? className : `${bp}:${className}`;\n          classNames.push(bpClassName);\n        }\n      }\n    }\n\n    return classNames.join(' ');\n  }\n\n  if (allowArbitraryValues) {\n    return className;\n  }\n}\n\nfunction getBaseClassName(\n  className: string,\n  value: string,\n  parseValue: (value: string) => string | undefined\n): string {\n  const delimiter = className ? '-' : '';\n  const matchedValue = parseValue(value);\n  const isNegative = matchedValue?.startsWith('-');\n  const minus = isNegative ? '-' : '';\n  const absoluteValue = isNegative ? matchedValue?.substring(1) : matchedValue;\n  return `${minus}${className}${delimiter}${absoluteValue}`;\n}\n\ninterface GetResponsiveCustomPropertiesOptions {\n  customProperties: `--${string}`[];\n  value: Responsive<Union> | Responsive<string> | undefined;\n  propValues: string[] | readonly string[];\n  parseValue?: (value: string) => string | undefined;\n}\n\nfunction getResponsiveCustomProperties({\n  customProperties,\n  value,\n  propValues,\n  parseValue = (value) => value,\n}: GetResponsiveCustomPropertiesOptions) {\n  let styles: Record<string, string | undefined> = {};\n\n  // Don't generate custom properties if the value is not arbitrary\n  if (!value || (typeof value === 'string' && propValues.includes(value))) {\n    return undefined;\n  }\n\n  if (typeof value === 'string') {\n    styles = Object.fromEntries(customProperties.map((prop) => [prop, value]));\n  }\n\n  if (isResponsiveObject(value)) {\n    const object = value;\n\n    for (const bp in object) {\n      // Make sure we are not iterating over keys that aren't breakpoints\n      if (!hasOwnProperty(object, bp) || !breakpoints.includes(bp)) {\n        continue;\n      }\n\n      const value = object[bp];\n\n      // Don't generate a custom property if the value is not arbitrary\n      if (propValues.includes(value)) {\n        continue;\n      }\n\n      for (const customProperty of customProperties) {\n        const bpProperty = bp === 'initial' ? customProperty : `${customProperty}-${bp}`;\n\n        styles = {\n          [bpProperty]: value,\n          ...styles,\n        };\n      }\n    }\n  }\n\n  for (const key in styles) {\n    const value = styles[key];\n    if (value !== undefined) {\n      styles[key] = parseValue(value);\n    }\n  }\n\n  return styles;\n}\n\nexport { getResponsiveStyles, getResponsiveCustomProperties, getResponsiveClassNames };\n", "type InlineStyle =\n  | React.CSSProperties\n  | Record<string, string | number | null | undefined>\n  | undefined;\n\n// Merges CSS styles like `classNames` merges CSS classes\nexport function mergeStyles(...styles: Array<InlineStyle>): InlineStyle {\n  let result: InlineStyle = {};\n\n  for (const style of styles) {\n    if (style) {\n      result = { ...result, ...style };\n    }\n  }\n\n  return Object.keys(result).length ? result : undefined;\n}\n"],
  "mappings": "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",
  "names": ["value", "classNames", "classNames"]
}
